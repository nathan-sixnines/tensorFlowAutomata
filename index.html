
<style>

.css-treeview ul,
.css-treeview li
{
	padding: 0;
	margin: 0;
	list-style: none;
    
      padding: 0.5em;
}

.uiBlock{

    list-style-position:inside;
    border: 2px solid gray;
    margin:5px;

}

.css-treeview input
{
	position: absolute;
	opacity: 1;
}

.css-treeview
{
	font: normal 11px "Segoe UI", Arial, Sans-serif;
	-moz-user-select: none;
	-webkit-user-select: none;
	user-select: none;
    
      color: white;
      background: rgba(90, 90, 90, 0.5);
      padding: 0.5em;
      position: fixed;
      top: 10px;
      right: 10px;
      width: 300px;
      
    z-index: 10
    
}

.css-treeview a
{
	color: #00f;
	text-decoration: none;

}

.css-treeview a:hover
{
	text-decoration: underline;
}

.css-treeview input + label + ul
{
	margin: 0 0 0 22px;
}

.css-treeview input + label + ul
{
	display: none;
}

.css-treeview label,
.css-treeview label::before
{
	cursor: pointer;
}

.css-treeview input:disabled + label
{
	cursor: default;
	opacity: .6;
}

.css-treeview input:checked:not(:disabled) + label + ul
{
	display: block;
}

.css-treeview label,
.css-treeview label::before
{
	background: url("icons.png") no-repeat;
}

.css-treeview label,
.css-treeview a,
.css-treeview label::before
{
	display: inline-block;
	height: 16px;
	line-height: 16px;,
	vertical-align: middle;
}

.css-treeview label
{
	background-position: 18px 0;
}

.css-treeview label::before
{
	content: "";
	width: 16px;
	margin: 0 22px 0 0;
	vertical-align: middle;
	background-position: 0 -32px;
}

.css-treeview input:checked + label::before
{
	background-position: 0 -16px;
}

/* webkit adjacent element selector bugfix */
@media screen and (-webkit-min-device-pixel-ratio:0)
{
	.css-treeview 
	{
		-webkit-animation: webkit-adjacent-element-selector-bugfix infinite 1s;
	}
	
	@-webkit-keyframes webkit-adjacent-element-selector-bugfix 
	{
		from 
		{ 
			padding: 0;
		} 
		to 
		{ 
			padding: 0;
		}
	}
}

.twitter-follow-button {
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 50%;
}

.Control {
  background: rgba(128, 128, 128, 0.5);
  padding: 0.5em;
  position: fixed;
  top: 10px;
  right: 10px;
  width: 729px;
  visibility: hidden;
}
.filterSmall {
  background: rgba(128, 128, 128, 0.5);
  padding: 0.5em;
  position: fixed;
  top: 10px;
  left: 10px;
  width: 70px;
  visibility: hidden;
}
</style>

<div class="css-treeview">
    <div class="uiBlock" style="">

    <h2 style="text-align:center;"> TensorFlow Automata </h2>
    <p style="text-align:center;">by Nathan Epstein<a href="https://twitter.com/Aeium?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Nathan @Aeium</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
    </div>
	<ul>
		<li class="uiBlock"><input type="checkbox" id="item-0" /><label for="item-a">Info</label>
            <ul>
                <p>This page is a UI for exploring patterns generated by repeated discrete convolution combined with a technique called even-zeroing. Even zeroing is an operation similar to Modulo, but only "enforced" on zeros.</p> 
                <p>Ex: (10,11,12,13) mod 2 -> (0,1,0,1) vs (10,11,12,13) Even-Zero-mod 2 -> (0,11,0,13).</p>
                <p>The results are congruent mod 2 but the even zero technique preserves the full value of the numbers that are not 0 respective to the modulus. This allows for a greater variety and depth of color in the visualization. There are many possibilities, some seem chaotic and random and others seem bizarrely deliberate.<p>
                <p>Gallery Link coming soon</p>
                <p>Controls:</p>
                <p>Advance the automaton using the button in basic controls, or use the W key. The convolutional filters can be edited in Automton Parameters -> Conv Filter Editor. Even-zero-mods can be edited in Automaton Parameters -> mods</p>
            </ul>
        </li>
		<li class="uiBlock"><input type="checkbox" id="item-0" /><label for="item-b">Basic Controls</label>
			<ul>

						<li><button onclick="advanceAuto()">Advance Automaton (W key)</button></li>
						<li><button onclick="resetAuto()">Reset Automaton (R key)</button></li>
			</ul>
		</li>
		<li class="uiBlock"><input type="checkbox" id="item-0" /><label for="item-0">Display Settings</label>
			<ul>

						<li><button onclick="reSize()">Resize Canvas</button></li>
						<li> <p>Automata Iteration Display Stride:<input type="text" id="Stride" value="1" style="position:relative; background: rgba(230,230,230,.5); z-index: 5; border:2px white; visibility: visible; 
  color: white; color:black;" onkeyup="setDispStride(this.value)" ></p></li>
						<li><input onclick="togAnimate()" type="checkbox" id="item-0-1" /><label for="item-0-1">Toggle Animate</label></li>
						<li><input onclick="toggleCounter()" type="checkbox" id="item-0-2" /><label for="item-0-2">Toggle Iteration Counter</label></li>
			</ul>
		</li>
		<li class="uiBlock"><input type="checkbox" id="item-1" /><label for="item-1">Automaton Parameters</label>
			<ul>

						<li><li><input onclick="patternView()" type="checkbox" id="item-1-1" /><label for="item-1-1">Conv Filter Editor</label></li></li>
						<li> <p>Mods: (comma seperate for multiple mods)<input type="text" id="Stride" value="2" style="position:relative; background: rgba(230,230,230,.5); z-index: 5; border:2px white; visibility: visible; 
  color: white; color:black;" onkeyup="setMods(this.value)"></p></li>
			</ul>
		</li>
		<li class="uiBlock"><input type="checkbox" id="item-0" /><label for="item-b">Pixel Edit</label>
			<ul>
						<li> <p>Pixel Edit Value<input type="text" id="Stride" value="1" style="position:relative; background: rgba(230,230,230,.5); z-index: 5; border:2px white; visibility: visible; 
  color: white; color:black;" onkeyup="setPixEdit(this.value)" ></p></li>
						<li><input onclick="togPixEdit()" type="checkbox" id="item-0-1" /><label for="item-3-1">Toggle Pixel Edit Mode</label></li>
			</ul>
	</ul>
</div>


<div id="container">
<canvas id="myCanvas" style="position:fixed; left:0; top:0; width:100%; height:100%; zindex:1;">
Your browser does not support the HTML5 canvas tag.</canvas>

<canvas id="myCanvas2" width="729" height="729" style="position:fixed; border:1px solid #d3d3d3; zindex:5; display: none">
Your browser does not support the HTML5 canvas tag.</canvas>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/0.14.2/tf.min.js"> </script>

<script>

/* old html
<div class="Control">

 <button onclick="reSize()">Resize Canvas</button>
 <button onclick="patternView()">Filter Editor</button>
 <button onclick="setMods()">Set Mods</button>
 <button onclick="advanceAuto()">Advance Automation (W key also works)</button>
 <button onclick="toggleCounter()">Toggle Counter</button>
 <button onclick="togAnimate()">Toggle Animate</button>
 
 <p> Page built by Nathan Epstein (Aeium) </p>


<div class="filterSmall">

    <p> Filter Edit </p>

    <button onclick="expandFilter()">Expand</button>

</div>
*/


// https://css-tricks.com/snippets/css/nested-expandable-folders/ source for treeview UI

//<script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js">

/*<script type='text/javascript' src='E:\numjs_local\dist\numjs.js'>

<script src="math.min.js" type="text/javascript">*/

function getParameterByName(name, url) {
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}

var canvas = document.getElementById("myCanvas");
var ctx    = canvas.getContext("2d");

var canvas2 = document.getElementById("myCanvas2");
var ctx2    = canvas2.getContext("2d");

var heightCanvas = parseInt(getParameterByName('cH'))
var widthCanvas  = parseInt(getParameterByName('cW'))
var heightPixels = parseInt(getParameterByName('pH'))
var widthPixels  = parseInt(getParameterByName('pW'))

var reload = false

var defaultHeight = window.innerHeight
var defaultWidth  = window.innerWidth
var defaultHeightCells = Math.floor(window.innerHeight/4)
var defaultWidthCells = Math.floor(defaultHeightCells * (defaultWidth/defaultHeight))

if(mod(defaultWidthCells,2) == 0){
    defaultWidthCells -= 1
}
if(mod(defaultHeightCells,2) == 0){
    defaultHeightCells -= 1
} 

var frame2Size = 729

console.log(window.innerHeight)
console.log(Math.floor(window.innerHeight/4))

var displayCounter = true

// load defaults if arguments are not provided
if(isNaN(heightCanvas)){heightCanvas = defaultHeight; reload = true;}
else if(heightCanvas != window.innerHeight){
    ctx.canvas.height = heightCanvas

}
if(isNaN(widthCanvas)){widthCanvas  = defaultWidth; reload = true;}
else if(widthCanvas != window.innerWidth){
    ctx.canvas.width = widthCanvas

}
if(isNaN(heightPixels)){heightPixels =  defaultHeightCells; reload = true;}
if(isNaN(widthPixels)){widthPixels  =  defaultWidthCells; reload = true;}

document.getElementById('myCanvas').style.height = heightCanvas
document.getElementById('myCanvas').style.width = widthCanvas
    
console.log("~~~~~")
    
console.log(getParameterByName('hC'))

if(reload){

    window.location.search += '&cH='+heightCanvas.toString()+'&cW='+widthCanvas.toString()+'&pH='+heightPixels.toString()+'&pW='+widthPixels.toString()

}

function reSize() {
    var txt;
    var vars = prompt("Edit numbers to reload canvas with new dimensions: \n <Canvas Height, Canvas Width, Active Cells Y, Active Cells X>", heightCanvas.toString() + ", " + widthCanvas.toString()+ ", " + heightPixels.toString()+ ", " + widthPixels.toString());
    varList = vars.split(',')
    var pass = false
    
    console.log(varList.length)
    
    console.log(!isNaN(varList[0]) && !isNaN(varList[1]) && !isNaN(varList[2]) && !isNaN(varList[3]))

    if(varList.length == 4){
    
        console.log(varList)
    
        if(!isNaN(varList[0]) && !isNaN(varList[1]) && !isNaN(varList[2]) && !isNaN(varList[3])){     
            console.log("pass number check")     
            pass = true
        }
    }
    
    if (!pass) {
        txt = "Invalid input, no changes made";
    } else {
        
        heightCanvas = parseInt(varList[0])
        widthCanvas  = parseInt(varList[1])
        heightPixels = parseInt(varList[2])
        widthPixels  = parseInt(varList[3])
         
        window.location.search = '&cH='+heightCanvas.toString()+'&cW='+widthCanvas.toString()+'&pH='+heightPixels.toString()+'&pW='+widthPixels.toString()
        
    }
    //document.getElementById("demo").innerHTML = txt;
}

var patternViewDisplay = false

function patternView(){
    if(patternViewDisplay == false){
        document.getElementById('myCanvas2').style.display = "block"
        patternViewDisplay = true
    } else {
        document.getElementById('myCanvas2').style.display = "none"
        patternViewDisplay = false
    }

    console.log(document.getElementById('myCanvas2').style.display)

    console.log(patternViewDisplay)
    
}

var modList  = [2]
var globalMod = 131072

function setMods(modsStr){

    var modsStrArray = modsStr.split(',')
    
    console.log(modsStrArray)
    
    modList = []
    
    for (var i = 0; i < modsStrArray.length; i++){
    
        console.log(modsStrArray[i])
        console.log(isNaN(modsStrArray[i]))
        
    
        if(! isNaN(modsStrArray[i])){
            modList.push(parseInt(modsStrArray[i]))
        }
    
    }
    
    //console.log(modList)
    
    globalMod = modList[0]
    var count = 1
        
    console.log(globalMod)
    while(globalMod < 65536*2){
        
        //console.log(globalMod)
        globalMod = globalMod * modList[mod(count,modList.length)]
        count++
        //console.log(globalMod)
    }
    
    //console.log(globalMod)


}


var cellSize = 1

var templateSize = 5

var displayStride = 1

function setDispStride(newVal){

    displayStride = parseInt(newVal)
}

var pixEditVal = 1

function setPixEdit(newVal){

    pixEditVal = newVal

}

var calcBatch = 0     // keep track of what frame until next delay

var displayStartFrame  = 1

var frameNum = 0

function mod(n, m) {
        return ((n % m) + m) % m;
}

function modularPaddArray(prePadArray, border){  // buffer should be input tile radius

    var ppa = prePadArray
    var b   = (border.shape[0]-1) /2   // size of padding
       
    var upper_pad = ppa.slice([ppa.shape[0]-b,0],[b,ppa.shape[1]])
    var lower_pad = ppa.slice([0,0],[b,ppa.shape[1]])
    
    var partial   = tf.concat([upper_pad, ppa, lower_pad], axis = 0)
    
    var left_pad  = partial.slice([0,partial.shape[1] - b],[partial.shape[0],b])
     
    var right_pad = partial.slice([0,0],[partial.shape[0],b])
  
    return tf.concat([left_pad, partial, right_pad], axis = 1) ////console.log(padded)

}


function setPix1(x, y, value){

    if(value != 0) {value += 200}

    var color1 = (value / 2) % 256
    var color2 = (value / 4) % 256
    var color3 = (value / 8) % 256

    setPix(x,y, color1, color2, color3)

}

function setPix(x, y, r, g, b){


    var xPix = x * cellSize;
    var yPix = y * cellSize;

    ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
    
    ctx.fillRect(xPix, yPix , cellSize, cellSize);

}

function applyRule1(readFrame, filter){

    //var border = (template.shape[0] -1) / 2
    
    //var paddedReadFrame = modularPaddArray(readFrame, border)
    
    //console.log(readFrame.shape)
    //console.log(paddedReadFrame.shape)
    //console.log(template.shape)
    
    var padded = modularPaddArray(readFrame, filter)
    
    console.log(padded.shape)
    
    console.log("before conv")
    
    readFrame.assign(tf.conv2d(padded, filter, [1,1],'valid'))

}

function applyRule2(frame, modList){


// https://js.tensorflow.org/api/0.6.1/#clipByValue

// with clipby value I can have more mods!
        
    console.log(modList)
    console.log("GLOBAL MOD = " + globalMod.toString())

    for(var i = 0; i < modList.length; i++){
    
        // we can do more interesting colorations if the mod is 2
        // because we can multiply the remainders with the original numbers without messing them up
        

        
        if(modList[i] == 2){
        
            frame.assign(frame.mul(frame.mod(tf.scalar(2))))
            //frame.assign(frame.mod(tf.scalar(65536)))  // this solves some of the overflow problems
            //frame.assign(frame.mod(tf.scalar(4096)))  // this solves some of the overflow problems
         
        
        }
        else{
        
            //frame.assign(frame.mod(tf.scalar(modList[i])))
            
            //console.log("MOD: " + modList[i])
            
            //frame.mod(tf.scalar(modList[i])).print()
            
            //frame.mod(tf.scalar(modList[i])).clipByValue(0,1).print()
            
            frame.assign(frame.mul(frame.mod(tf.scalar(modList[i])).sub(tf.scalar(modList[i])).mod(tf.scalar(modList[i])).clipByValue(0,1)))
        }

    }
    
    //frame.print()
    
    frame.assign(frame.mod(tf.scalar(globalMod)))

   //return frame
 
}

/*
function display(frame){

    var s0 = frame.shape[0]
    var s1 = frame.shape[1]

    list = frame.tolist()
    for(var i = 0; i < s0; i++){
        for(var j = 0; j < s1; j++){
        
            setPix1(i,j,list[i][j])
        
        }
    }
    
}*/


//var frame1 = nj.zeros([frameSize,frameSize])
//var frame2 = nj.zeros((frameSize,frameSize), dtype = uint32)

// https://stackoverflow.com/questions/34685947/adjust-single-value-within-tensor-tensorflow/34686952#34686952

var values = new Array(heightPixels * widthPixels).fill(0);
var startValue = 1  // maybe allow this to be changed later
values[Math.floor(heightPixels*widthPixels/2)] = startValue
const frame1 = tf.variable(tf.tensor(values, [heightPixels,widthPixels,1]))


function resetAuto(){

    tf.tidy(() => {

        values = new Array(heightPixels * widthPixels).fill(0);
        startValue = 1  // maybe allow this to be changed later
        values[Math.floor(heightPixels*widthPixels/2)] = startValue
        frame1.assign(tf.tensor(values, [heightPixels,widthPixels,1]))
    
    })
    
    frameNum = 0
    display (frame1)
    
    tf.toPixels(displayVar2, canvas).then(function(){
    
        if(displayCounter){
            ctx.font = Math.floor(widthCanvas/15).toString() + "px Arial"
            ctx.fillStyle = "white"
            ctx.fillText(frameNum.toString() , canvas.width- canvas.width*(19/20), canvas.height -      canvas.height*(1/20))}
    })

}

function pixEdit(xCo, yCo){

    //console.log(values.length)
    
    //console.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    //console.log(heightPixels)
    //console.log(widthPixels)
    //console.log(widthPixels*heightPixels)

    tf.tidy(() => {

        values = new Array(heightPixels * widthPixels).fill(0);
        editValue = pixEditVal
        values[yCo * widthPixels + xCo] = editValue
        frame1.assign(frame1.add(tf.tensor(values, [heightPixels,widthPixels,1])))
    
    })
    
    display (frame1)
    
    tf.toPixels(displayVar2, canvas).then(function(){
    
        if(displayCounter){
            ctx.font = Math.floor(widthCanvas/15).toString() + "px Arial"
            ctx.fillStyle = "white"
            ctx.fillText(frameNum.toString() , canvas.width- canvas.width*(19/20), canvas.height -      canvas.height*(1/20))}
    })
    
}

pixEditMode = false

function togPixEdit(){

    pixEditMode = !pixEditMode

}

//frame1.print()

//var template = nj.array([[0,1,1,1,1,0],[1,0,0,0,0,1],[1,0,1,0,0,1],[0,1,1,1,1,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,0,0,1,0,0,],[0,1,1,1,1,1,],[0,0,0,0,0,0],[0,0,1,1,1,0],[0,1,0,1,0,1],[0,0,1,0,0,1],
 //                       [0,0,0,0,0,0],[1,0,1,1,1,1],[0,0,0,0,0,0],[0,0,1,1,1,0],[0,0,0,0,0,1],[0,0,0,0,0,1],[0,0,1,1,1,0],[0,0,0,0,0,0],[0,0,0,1,1,1],[0,0,1,0,0,0],[0,0,0,1,1,1],[0,0,1,0,0,0],[0,0,0,1,1,1]])

//var templateTop = nj.zeros([25,9])
//var templateBot = nj.zeros([25,10])

//var template = nj.ones([9,9])

////console.log(template.shape)
////console.log(templateTop.shape)

//template = nj.concatenate(nj.concatenate(templateTop, template), templateBot)

                        
//console.log(template.shape)

var filterValues = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
 
/* 
const template3  = tf.variable(tf.zeros([ 3, 3,1,1]))
const template5  = tf.variable(tf.zeros([ 5, 5,1,1]))
const template7  = tf.variable(tf.zeros([ 7, 7,1,1]))
const template9  = tf.variable(tf.zeros([ 9, 9,1,1]))
const template11 = tf.variable(tf.zeros([11,11,1,1]))
*/

const template3  = tf.variable(tf.ones([ 3, 3,1,1]))
const template5  = tf.variable(tf.ones([ 5, 5,1,1]))
const template7  = tf.variable(tf.ones([ 7, 7,1,1]))
const template9  = tf.variable(tf.ones([ 9, 9,1,1]))
const template11 = tf.variable(tf.zeros([11,11,1,1]))
const template13 = tf.variable(tf.zeros([13,13,1,1]))
const template15 = tf.variable(tf.zeros([15,15,1,1]))
const template17 = tf.variable(tf.ones([17,17,1,1]))

var templateList = [template3, template5, template7, template9, template11, template13, template15, template17]

var whichTempate = 1  // 0 -> 3, 1 -> 5, 2 -> 7, 3 -> 9, 4 -> 11  thats about as close to making sense as this will get I think



setPatternGridSize(templateList[whichTempate].shape[0])

ctx.fillStyle = 'rgb(0,0,0)';

ctx.fillRect(0,0, heightPixels, widthPixels);


//console.log(template.shape)

//array = nj.array([1,2,3,4,5,6,7,8,9])

//console.log("what")

//console.log(array)

//console.log("testing math.js")

function resetGrid(){

ctx2.fillStyle = 'rgb(255,255,255)';
ctx2.fillRect(0, 0, frame2Size, frame2Size)

ctx2.fillStyle = 'rgb(0,0,0)';

// template grid select buttons
for(var i = 0; i < 8; i++){
    ctx2.fillRect(40+80*i, 40, 40, 40)
}

ctx2.fillRect(40, frame2Size - 80, 80, 40)


}

function invertConvPattern(){

    templateList[whichTempate].assign(templateList[whichTempate].add(tf.scalar(1)).mod(tf.scalar(2)))
    displayTemplateGrid()

}



function setPatternGridSize(size){

    // 0 -> 3, 1 -> 5, 2 -> 7, 3 -> 9, 4 -> 11  

    var targetTemplate = Math.floor(size / 2) - 1

    var gridSize = (whichTempate+1) * 2 + 1

    //console.log(targetTemplate)
    //console.log(whichTempate)
    
   // console.log(templateList[targetTemplate].shape)
    //console.log(templateList[targetTemplate].print())
    
    console.log(size)
    
    console.log(gridSize)
    
    if(size > gridSize){
    
        console.log("size > gridsize")
        
        var diff = (size - gridSize)/2
        
        console.log(diff)
        
        console.log(templateList[whichTempate].shape)
        
        templateList[whichTempate].pad([[diff,diff],[diff,diff],[0,0],[0,0]]).print()
        
        console.log("test")
        
        //console.log(templateList[whichTempate].pad([diff,diff],[diff,diff]).shape)
    
        //templateList[targetTemplate].assign(templateList[whichTempate].pad([diff,diff],[diff,diff]))
    
    }
    
    if(size < gridSize){
    
        var diff = (gridSize - size)/2
    
        //console.log(diff)
        //console.log(gridSize)
    
        //templateList[whichTempate].print()
        
        //templateList[whichTempate].slice([diff, diff],[gridSize-diff*2,gridSize-diff*2]).print()
    
        templateList[targetTemplate].assign(templateList[whichTempate].slice([diff, diff],[gridSize-diff*2,gridSize-diff*2]))
    
    }
    
    whichTempate = targetTemplate
    
    //console.log(whichTempate)
    
    //templateList[whichTempate].print()
    
    displayTemplateGrid()

}

function displayTemplateGrid(){

    resetGrid()  // just graphics here no matrix stuff
    var gridSize = (whichTempate+1) * 2 + 1

    var space = frame2Size - 240

    var gridStride = Math.floor(space / gridSize)
    
    var JSarray = templateList[whichTempate].dataSync()
    
    for(var j = 0; j < gridSize; j++){
        for(var i = 0; i < gridSize; i++){
    
            //ctx2.fillText(list[i][j].toString(), i*gridStride, j*gridStride)
            
            if(JSarray[(gridSize-1-j)*gridSize+(gridSize-1-i)] == 1){
                ctx2.fillRect(i*gridStride + 120 + 2, j*gridStride+120 + 2, gridStride - 2, gridStride - 2)
            }
            else{
                ctx2.fillRect(i*gridStride + 120 + 2, j*gridStride+120 + 2, gridStride - 2, gridStride - 2)
                ctx2.fillStyle = 'rgb(255,255,255)';
                ctx2.fillRect(i*gridStride + 120 + 8, j*gridStride+120 + 8, gridStride - 14, gridStride - 14)
                ctx2.fillStyle = 'rgb(0,0,0)';
            }
        }
    }
    

}

function flipTemplateBit(Ypix, Xpix){

    var gridSize = (whichTempate+1) * 2 + 1
    var space = frame2Size - 240
    var gridStride = Math.floor(space / gridSize)

    for(var i = 0; i < gridSize; i++){
        for(var j = 0; j < gridSize; j++){
    
            if(Xpix > (i*gridStride + 120 + 2)
                && Xpix <  ((i+1)*gridStride + 120 + 2)
                && Ypix >  ((j)*gridStride + 120 + 2)
                && Ypix <  ((j+1)*gridStride + 120 + 2)){
            
                    //console.log("ypix: " + Ypix.toString() + " xpix: " + Xpix.toString())
                    //console.log(i)
                    //console.log(j)
                    
                    flipTemplateBit2((gridSize-1-j),(gridSize-1-i))
            }
        }
    }
    
    displayTemplateGrid()

}

function flipTemplateBit2(y,x){

    console.log("flipTemplateBit2 y:" + y.toString() + " x: " + x.toString())

    var filterList = new Array(templateList[whichTempate].shape[0] * templateList[whichTempate].shape[1]).fill(0)
    
    console.log(templateList[whichTempate].shape)
    
    var TemplateDim1 = templateList[whichTempate].shape[0]
    var TemplateDim2 = templateList[whichTempate].shape[1]
    
    filterList[y*templateList[whichTempate].shape[1]+x] = 1

    console.log("1")
    
    templateList[whichTempate].print()
    
    console.log("2")
    
    tf.tensor(filterList,[TemplateDim1,TemplateDim2,1,1]).print()
    
    console.log("3")
    
    templateList[whichTempate].add(tf.tensor(filterList,[TemplateDim1,TemplateDim2,1,1])).print()
    
    tf.mod(templateList[whichTempate].add(tf.tensor(filterList,[TemplateDim1,TemplateDim2,1,1])),tf.scalar(2)).print()
    
    templateList[whichTempate].assign(tf.mod(templateList[whichTempate].add(tf.tensor(filterList,[TemplateDim1,TemplateDim2,1,1])),tf.scalar(2)))

}


const scalar16    = tf.scalar(16)
const scalar32    = tf.scalar(32)
const scalar64    = tf.scalar(64)
const scalar128   = tf.scalar(128)
const scalar256   = tf.scalar(256)

//const displayStartValues1 = tf.concat([tf.zerosLike(frame1),tf.zerosLike(frame1),tf.zerosLike(frame1)],2)

const displayVar1 = tf.variable(tf.zeros([heightPixels,widthPixels,3]))

//const displayStartValues2 = tf.concat([tf.zeros([frameSize, frameSize,1,1]),tf.zeros([frameSize, frameSize,1,1]),tf.zeros([frameSize, frameSize,1,1])],2)

const displayVar2 = tf.variable(tf.zeros([heightCanvas,widthCanvas,3]))


function display (frame1){   // this does not actually call to pixels but gets the displayVars assigned properly

    //console.log(frame1.dtype)
    //console.log(scalar2.dtype)
    //console.log(scalar4.dtype)
    //console.log(scalar256.dtype)

    //console.log(frame1.shape)
    
    console.log(frameNum)
    
    console.log(mod((frameNum + displayStartFrame - displayStride),displayStride)) 
    
    if(mod(frameNum,displayStride)  == displayStartFrame || displayStride == 1){
    
        // multiply first to highlist colors
        
        console.log("displaying")
        
        //console.log(displayVar1.shape)
        //console.log(frame1.shape)
        
    
        displayVar1.assign(tf.concat([frame1.mod(scalar256).div(scalar256),
                                     frame1.mul(scalar32).mod(scalar256).div(scalar256),
                                     frame1.mul(scalar128).mod(scalar256).div(scalar256)],2))
                                     
        
        displayVar2.assign(tf.image.resizeNearestNeighbor(displayVar1, [heightCanvas,widthCanvas]))
        //displayVar2.assign(tf.image.resizeBilinear(displayVar1, [frameSize,frameSize]))
    

    }
    
}

function toggleCounter(){

    displayCounter = ! displayCounter
    
    tf.toPixels(displayVar2, canvas).then(function(){
    
        if(displayCounter){
            ctx.font = Math.floor(widthCanvas/15).toString() + "px Arial"
            ctx.fillStyle = "white"
            ctx.fillText(frameNum.toString() , canvas.width- canvas.width*(19/20), canvas.height -      canvas.height*(1/20))}
    })

}

function clearFrame(){

    tf.tidy(() => {
    frame1.assign(tf.tensor(values, [displayPixelSize,displayPixelSize,1]))
    frameNum = 0
    display(frame1)
    })

}

var animate = false

function togAnimate(){

    animate = ! animate

}

function advanceAuto(){

            console.log("DISPLAYSTRIDE = " + displayStride.toString())

            console.log(frameNum)
            if(displayStride != 1){
                while(true){
            
                    console.log("DISPLAYSTRIDE = " + displayStride.toString())
            
                    console.log(mod(frameNum,2))
                    console.log(mod(frameNum+1,2))
            
                    console.log(displayStride)
            
                    console.log(mod(frameNum,displayStride)) 
                    console.log(mod((frameNum + 1),displayStride)) 
                    
                    console.log("displayStart = " + displayStartFrame.toString())
    
                    if(mod((frameNum + 1),displayStride)   == displayStartFrame){
    
                        tf.tidy(() => {
                
                            console.log(frame1.shape)
                            applyRule1(frame1, templateList[whichTempate])
                            console.log(frame1.shape)
                            //console.log("test1")
                            applyRule2(frame1, modList)
                            frameNum++
                            console.log(frameNum)
                            console.log("disp loop")
                            display(frame1)
                        })
                        
                        tf.toPixels(displayVar2, canvas).then(function(){
                        
                            if(displayCounter){
                                ctx.font = Math.floor(widthCanvas/15).toString() + "px Arial"
                                ctx.fillStyle = "white"
                                ctx.fillText(frameNum.toString() , canvas.width- canvas.width*(19/20), canvas.height -      canvas.height*(1/20))
                            }
                            
                            if(animate){
                                window.requestAnimationFrame(advanceAuto);
                            }
                            
                        })
                        

                        break
                    }
                    else{
            
                        tf.tidy(() => {
                
                            console.log(frame1.shape)
                            applyRule1(frame1, templateList[whichTempate])
                            console.log(frame1.shape)
                            //console.log("test1")
                            applyRule2(frame1, modList)
                            frameNum++
            
                            //frame1.print()
                            //template.print()
            
                            console.log("process loop")
    
                        });
                    }
                }
            }
                
            else{
                
                    tf.tidy(() => {
                    
                        console.log(frame1.shape)
                        applyRule1(frame1, templateList[whichTempate])
                        console.log(frame1.shape)
                        //console.log("test1")
                        applyRule2(frame1, modList)
                        frameNum++
            
                        //frame1.print()
                        //template.print()
                        console.log(frameNum)
                        console.log("disp loop")
                        display(frame1)
                        
                    }); 
                    
                    tf.toPixels(displayVar2, canvas).then(function(){
                    
                        if(displayCounter){
                            ctx.font = Math.floor(widthCanvas/15).toString() + "px Arial"
                            ctx.fillStyle = "white"
                            ctx.fillText(frameNum.toString() , canvas.width- canvas.width*(19/20), canvas.height -      canvas.height*(1/20))
                        }
                        
                        if(animate){
                            window.requestAnimationFrame(advanceAuto);
                        }
                        
                    })
                    

            }
            
        console.log("number of tensors:")
        console.log(tf.memory().numTensors)
        console.log("~~~~~~~~~~~~~~~~~")
            
}

document.onkeydown = function(e) {
    switch (e.keyCode) {
        case 8:
        
            clearFrame()
            break
    
        case 87:
        
            console.log("w key pressed")
            advanceAuto()

            break
    }
}
        
document.getElementById("container").addEventListener('click', function(event) {

    //frame1.print()
    //template.print()
    

    //tf.toPixels(frame1, canvas)
    
    
    var canvas1Left = canvas.offsetLeft;
    var canvas1Top  = canvas.offsetTop;
    
    var pixX1 = event.pageX - canvas1Left;
    var pixY1 = event.pageY - canvas1Top;
    
    var canvas2Left = canvas2.offsetLeft;
    var canvas2Top  = canvas2.offsetTop;
    
    var pixX2 = event.pageX - canvas2Left;
    var pixY2 = event.pageY - canvas2Top;
    
    
    //if(pixY1 >= 0 && pixY1 <= frameSize){

        // these functions both assign the new value to frame1 so they don't need to return anything

    //}
    //else{
    if(document.getElementById('myCanvas2').style.display != 'none'){  // edit conv pattern via clicks

    
        if(pixY2 >= 40 && pixY2 <= 80){
    
            if(mod(pixX2,80) >= 40){
        
                var gridSize = 1+ 2 * (Math.floor(pixX2 / 80) + 1)
        
                setPatternGridSize(gridSize)


            }
        }
        
        if(pixY2 >= 120){
        
            flipTemplateBit(pixY2, pixX2)
        
        }
        
        if(pixY2 > frame2Size - 80 && pixY2 < frame2Size - 40 && pixX2 > 40 && pixX2 < 120){
        
            invertConvPattern()
        
        }
    } else if (pixEditMode){  // edit pixels in main canvas // for now easier to not allow both types of click edits at the same time
    
            //var heightCanvas = parseInt(getParameterByName('cH'))
            //var widthCanvas  = parseInt(getParameterByName('cW'))
            //var heightPixels = parseInt(getParameterByName('pH'))
            //var widthPixels  = parseInt(getParameterByName('pW'))
    
            var editX = Math.floor(pixX1 / (widthCanvas / widthPixels))
            var editY = Math.floor(pixY1 / (heightCanvas / heightPixels))
    
            pixEdit(editX, editY)
    
    }
    
}); 

resetAuto()


</script>